% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Class-DasymetricSurface.R
\name{EtrsDasymetricSurface}
\alias{EtrsDasymetricSurface}
\title{The DasymetricSurface class}
\usage{
EtrsDasymetricSurface(input.surface.grided, ancillary.grided, ...)

EtrsDasymetricSurface(input.surface.grided, ancillary.grided, ...)
}
\arguments{
\item{ancillary.grided}{}
}
\value{
An DasymetricSurface Object

EtrsDasymetricSurface
}
\description{
The DasyemetricSurface class holds the basic information for dasymetric surface represanation in ETRS-LAEA grid form

P_mu = (R_A x P_A ) x N / E
P_cell = (R_A x P_A /P_A ) x (N / A_T ) / E = (R_A x N / A_T ) / E
Where,
  P_cell is the population of a cell,
  R_A is the relative density of a cell with land-cover type A,
  P_A is the proportion of cells of land-cover type A in the
  enumeration unit.
  N is the actual population of enumeration unit
  (i.e., census block B group)
  E is the expected population of enumeration unit calculated
  using the relative densities.
  A_T is the total number of cells in the enumeration unit.
  P_A / P_A cancels P_A out of the equation, i.e., not used in the cell-
    based method.
}
\section{Slots}{

\describe{
\item{\code{SpatialPolygonsDataFrame.}}{the input surface plus new data columns}

\item{\code{over.method.type}}{character. MaxArea for categorical data PropCal for numeric #'values}

\item{\code{cell.size}}{numeric. Indexing the column of data frame that contains the value of #'interest}

\item{\code{CELLVALUE}}{character. The size of the cell (the new map unit)}
}}
\examples{
# test Dasymetric  -------------------------------------------------------
# Make a spatial polygon
S<-readWKT("POLYGON((0 0,2000 0,2000 2000,0 2000,0 0))",id = "S",p4s = CRS("+init=epsg:3035"))
df<-cbind(AREA=gArea(S),VALUE=1000)
row.names(df)<-sapply(slot(S,"polygons"),function(x) slot(x,"ID"))
df<-as.data.frame(df)
S<-SpatialPolygonsDataFrame(S,data = df,match.ID = TRUE)
# Covert actuall value to density
S<-ActuallVal2Density(input.surface = S,surface.value.col = 2,area.unit = 1e+06)
# plot
X11(width=12,height = 12)
split.screen(figs = c(3,2))
screen(1)
plot(S)
title("the input surface")
text(coordinates(S)[,1],coordinates(S)[,2],S[["VALUE"]])
text(coordinates(S)[,1],coordinates(S)[,2],S[["VALUE"]])
#grided
S.grided <- etrsSourceSurface(input.surface = S,over.method.type = "PropCal",surface.value.col = 2,cell.size = 500)
screen(2)
plot(S.grided)
title("... Projected to ETRS-LAEA 500 m")
text(coordinates(S.grided)[,1],coordinates(S.grided)[,2],S.grided[["CELLVALUE"]])

#the ancillary surface
A<-readWKT("POLYGON((0 0,1000 0,1000 500,0 500,0 0))",id="A" ,p4s = CRS("+init=epsg:3035" ))
df<-cbind(AREA=gArea(A),RelDens=1)
row.names(df)<-sapply(slot(A,"polygons"),function(x) slot(x,"ID"))
df<-as.data.frame(df)
A<-SpatialPolygonsDataFrame(A,data = df,match.ID = TRUE)
screen(3)
plot(S,border="lightgrey")
plot(A,add=T)
title("the ancillary surface")
text(coordinates(A)[,1],coordinates(A)[,2],A[["RelDens"]])
#grided
A.grided <- etrsAncillarySurface(input.surface = A,over.method.type = "PropCal",surface.value.col = 2,cell.size = 500,binary = FALSE)
screen(4)
plot(S.grided,border="lightgrey")
plot(A.grided,add=T)
title("... Projected to ETRS-LAEA 500 m")
text(coordinates(A.grided)[,1],coordinates(A.grided)[,2],A.grided[["WCELLWEIGHT"]])
#EtrsDasymetric
screen(6)
D.grided<-EtrsDasymetricSurface(input.surface.grided = S.grided,ancillary.grided = A.grided,actuall.value = TRUE)
plot(S.grided, border = "lightgrey")
plot(D.grided,add=T)
title("Finally the Dasymetric Surface")
text(coordinates(D.grided)[,1],coordinates(D.grided)[,2],D.grided[["DASYCELL"]])
}

